CFOLD: # --- File: src/evid/gui/tabs/browse_evidence.py ---
CFOLD: from PyQt6.QtWidgets import (
CFOLD:     QWidget,
CFOLD:     QVBoxLayout,
CFOLD:     QHBoxLayout,
CFOLD:     QLabel,
CFOLD:     QComboBox,
CFOLD:     QPushButton,
CFOLD:     QTableWidget,
CFOLD:     QTableWidgetItem,
CFOLD:     QMessageBox,
CFOLD:     QHeaderView,
CFOLD:     QLineEdit,
CFOLD: )
CFOLD: from PyQt6.QtCore import Qt
CFOLD: from pathlib import Path
CFOLD: import yaml
CFOLD: import subprocess
CFOLD: import logging
CFOLD: from evid.core.label_setup import textpdf_to_latex, csv_to_bib
CFOLD: from evid.core.rebut_doc import rebut_doc
CFOLD: import arrow
CFOLD: from evid import DEFAULT_DIR
CFOLD: 
CFOLD: # Set up logging with detailed output
CFOLD: logging.basicConfig(level=logging.DEBUG)
CFOLD: logger = logging.getLogger(__name__)
CFOLD: 
CFOLD: 
CFOLD: class BrowseEvidenceTab(QWidget):
CFOLD:     def __init__(self, directory: Path = DEFAULT_DIR):
CFOLD:         super().__init__()
CFOLD:         self.directory = directory
CFOLD:         self.metadata_entries = []  # Store all metadata for filtering
CFOLD:         self.init_ui()
CFOLD: 
CFOLD:     def init_ui(self):
CFOLD:         layout = QVBoxLayout()
CFOLD: 
CFOLD:         # Dataset selection
CFOLD:         dataset_layout = QHBoxLayout()
CFOLD:         dataset_layout.addWidget(QLabel("Dataset:"))
CFOLD:         self.dataset_combo = QComboBox()
CFOLD:         self.dataset_combo.addItems(self.get_datasets())
CFOLD:         if self.dataset_combo.count() > 0:
CFOLD:             self.dataset_combo.setCurrentIndex(0)
CFOLD:         dataset_layout.addWidget(self.dataset_combo)
CFOLD:         dataset_layout.addWidget(QPushButton("Load", clicked=self.load_metadata))
CFOLD:         dataset_layout.addWidget(QPushButton("Open Dir", clicked=self.open_directory))
CFOLD:         layout.addLayout(dataset_layout)
CFOLD: 
CFOLD:         # Search field
CFOLD:         search_layout = QHBoxLayout()
CFOLD:         search_layout.addWidget(QLabel("Search:"))
CFOLD:         self.search_input = QLineEdit()
CFOLD:         self.search_input.setPlaceholderText("Search metadata...")
CFOLD:         self.search_input.textChanged.connect(self.filter_metadata)
CFOLD:         search_layout.addWidget(self.search_input)
CFOLD:         layout.addLayout(search_layout)
CFOLD: 
CFOLD:         # Table
CFOLD:         self.table = QTableWidget(0, 5)
CFOLD:         self.table.setHorizontalHeaderLabels(
CFOLD:             ["Author", "Title", "Date", "File Name", "UUID"]
CFOLD:         )
CFOLD:         self.table.setSortingEnabled(True)  # Enable sorting
CFOLD:         self.table.sortByColumn(2, Qt.SortOrder.DescendingOrder)  # Default sort by Date
CFOLD:         self.table.setSelectionMode(QTableWidget.SelectionMode.ExtendedSelection)  # Enable multi-selection
CFOLD: 
CFOLD:         # Set default column widths
CFOLD:         header = self.table.horizontalHeader()
CFOLD:         header.setSectionResizeMode(QHeaderView.ResizeMode.Interactive)
CFOLD:         self.table.setColumnWidth(0, 200)  # Author
CFOLD:         self.table.setColumnWidth(1, 250)  # Title
CFOLD:         self.table.setColumnWidth(2, 100)  # Date
CFOLD:         self.table.setColumnWidth(3, 150)  # File Name
CFOLD:         self.table.setColumnWidth(4, 150)  # UUID
CFOLD: 
CFOLD:         # Make columns stretch when window resizes
CFOLD:         header.setStretchLastSection(True)
CFOLD:         header.setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)  # Author
CFOLD:         header.setSectionResizeMode(1, QHeaderView.ResizeMode.Stretch)  # Title
CFOLD:         layout.addWidget(self.table)
CFOLD: 
CFOLD:         # Buttons
CFOLD:         button_layout = QHBoxLayout()
CFOLD:         button_layout.addWidget(QPushButton("Label Selected", clicked=self.create_labels))
CFOLD:         button_layout.addWidget(QPushButton("Generate BibTeX", clicked=self.generate_bibtex))
CFOLD:         button_layout.addWidget(QPushButton("Rebut", clicked=self.run_rebut))
CFOLD:         layout.addLayout(button_layout)
CFOLD: 
CFOLD:         self.setLayout(layout)
CFOLD: 
CFOLD:     def get_datasets(self):
CFOLD:         return (
CFOLD:             [
CFOLD:                 d.name
CFOLD:                 for d in self.directory.iterdir()
CFOLD:                 if d.is_dir() and not d.name.startswith(".")
CFOLD:             ]
CFOLD:             if self.directory.exists()
CFOLD:             else []
CFOLD:         )
CFOLD: 
CFOLD:     def load_metadata(self):
CFOLD:         dataset = self.dataset_combo.currentText()
CFOLD:         if not dataset:
CFOLD:             QMessageBox.warning(self, "No Dataset", "Please select a dataset to load.")
CFOLD:             return
CFOLD: 
CFOLD:         # Fully reset table and metadata
CFOLD:         self.table.setSortingEnabled(False)
CFOLD:         self.table.clearContents()
CFOLD:         self.table.setRowCount(0)
CFOLD:         self.metadata_entries = []
CFOLD:         logger.debug(f"Loading metadata for dataset: {dataset}")
CFOLD: 
CFOLD:         for info_file in self.directory.glob(f"{dataset}/**/info.yml"):
CFOLD:             try:
CFOLD:                 # Read raw content for debugging
CFOLD:                 with info_file.open("r", encoding="utf-8") as f:
CFOLD:                     raw_content = f.read()
CFOLD:                     logger.debug(f"Raw YAML for {info_file}: {raw_content}")
CFOLD: 
CFOLD:                 # Parse YAML
CFOLD:                 with info_file.open("r", encoding="utf-8") as f:
CFOLD:                     metadata = yaml.safe_load(f)
CFOLD: 
CFOLD:                 # Validate metadata
CFOLD:                 if metadata is None:
CFOLD:                     logger.warning(f"Skipping {info_file}: Empty or malformed YAML")
CFOLD:                     continue
CFOLD:                 if not isinstance(metadata, dict):
CFOLD:                     logger.warning(f"Skipping {info_file}: Expected dict, got {type(metadata).__name__}")
CFOLD:                     continue
CFOLD: 
CFOLD:                 # Log parsed metadata
CFOLD:                 logger.debug(f"Parsed metadata for {info_file}: {metadata}")
CFOLD: 
CFOLD:                 # Check for uuid presence
CFOLD:                 if "uuid" not in metadata:
CFOLD:                     logger.warning(f"Skipping {info_file}: Missing UUID field")
CFOLD:                     continue
CFOLD: 
CFOLD:                 # Parse date for sorting
CFOLD:                 date_str = str(metadata.get("time_added", "1970-01-01"))
CFOLD:                 try:
CFOLD:                     date = arrow.get(date_str, "YYYY-MM-DD")
CFOLD:                 except arrow.parser.ParserError:
CFOLD:                     date = arrow.get("1970-01-01")  # Fallback for invalid dates
CFOLD: 
CFOLD:                 self.metadata_entries.append((date, metadata))
CFOLD:             except yaml.YAMLError as e:
CFOLD:                 logger.error(f"YAML parsing error in {info_file}: {str(e)}")
CFOLD:                 continue
CFOLD:             except Exception as e:
CFOLD:                 logger.error(f"Failed to load {info_file}: {str(e)}")
CFOLD:                 continue
CFOLD: 
CFOLD:         # Sort entries by date (latest first)
CFOLD:         self.metadata_entries.sort(key=lambda x: x[0], reverse=True)
CFOLD:         logger.debug(f"Found {len(self.metadata_entries)} valid entries")
CFOLD: 
CFOLD:         # Populate table with all entries initially
CFOLD:         self.filter_metadata()
CFOLD: 
CFOLD:     def filter_metadata(self):
CFOLD:         search_text = self.search_input.text().strip().lower()
CFOLD:         self.table.setSortingEnabled(False)
CFOLD:         self.table.clearContents()
CFOLD:         self.table.setRowCount(0)
CFOLD: 
CFOLD:         for date, metadata in self.metadata_entries:
CFOLD:             # Convert all metadata values to strings and check for search text
CFOLD:             metadata_str = " ".join(
CFOLD:                 str(value).lower() for value in metadata.values()
CFOLD:             )
CFOLD:             if not search_text or search_text in metadata_str:
CFOLD:                 row = self.table.rowCount()
CFOLD:                 self.table.insertRow(row)
CFOLD: 
CFOLD:                 # Set table items with fallbacks
CFOLD:                 authors = str(metadata.get("authors", "Unknown"))
CFOLD:                 label = str(metadata.get("label", "Unknown"))
CFOLD:                 time_added = str(metadata.get("time_added", "Unknown"))
CFOLD:                 original_name = str(metadata.get("original_name", "Unknown"))
CFOLD:                 uuid_value = str(metadata.get("uuid", "Unknown"))
CFOLD: 
CFOLD:                 self.table.setItem(row, 0, QTableWidgetItem(authors))
CFOLD:                 self.table.setItem(row, 1, QTableWidgetItem(label))
CFOLD:                 self.table.setItem(row, 2, QTableWidgetItem(time_added))
CFOLD:                 self.table.setItem(row, 3, QTableWidgetItem(original_name))
CFOLD:                 self.table.setItem(row, 4, QTableWidgetItem(uuid_value))
CFOLD: 
CFOLD:                 logger.debug(f"Added row {row}: Authors={authors}, Label={label}, UUID={uuid_value}")
CFOLD: 
CFOLD:         self.table.setSortingEnabled(True)
CFOLD:         self.table.sortByColumn(2, Qt.SortOrder.DescendingOrder)
CFOLD: 
CFOLD:     def open_directory(self):
CFOLD:         row = self.table.currentRow()
CFOLD:         if row < 0:
CFOLD:             QMessageBox.warning(self, "No Selection", "Please select an evidence entry.")
CFOLD:             return
CFOLD: 
CFOLD:         dataset = self.dataset_combo.currentText()
CFOLD:         uuid_item = self.table.item(row, 4)
CFOLD:         if not uuid_item or not uuid_item.text() or uuid_item.text() == "Unknown":
CFOLD:             QMessageBox.critical(self, "Invalid Entry", "Selected entry has no valid UUID.")
CFOLD:             return
CFOLD: 
CFOLD:         uuid = uuid_item.text()
CFOLD:         path = self.directory / dataset / uuid
CFOLD:         if not path.exists():
CFOLD:             QMessageBox.critical(self, "Directory Missing", f"The directory {path} does not exist.")
CFOLD:             return
CFOLD: 
CFOLD:         try:
CFOLD:             subprocess.run(["code", str(path)], check=True)
CFOLD:         except subprocess.SubprocessError as e:
CFOLD:             QMessageBox.critical(self, "Error Opening VS Code", f"Failed to open directory in VS Code: {str(e)}")
CFOLD: 
CFOLD:     def create_labels(self):
CFOLD:         selected_rows = sorted(set(index.row() for index in self.table.selectedIndexes()))
CFOLD:         if not selected_rows:
CFOLD:             QMessageBox.warning(self, "No Selection", "Please select at least one evidence entry.")
CFOLD:             return
CFOLD: 
CFOLD:         dataset = self.dataset_combo.currentText()
CFOLD:         for row in selected_rows:
CFOLD:             uuid_item = self.table.item(row, 4)
CFOLD:             if not uuid_item or not uuid_item.text() or uuid_item.text() == "Unknown":
CFOLD:                 QMessageBox.critical(self, "Invalid Entry", f"Entry in row {row + 1} has no valid UUID.")
CFOLD:                 continue
CFOLD: 
CFOLD:             uuid = uuid_item.text()
CFOLD:             file_name = self.table.item(row, 3).text()
CFOLD:             file_path = self.directory / dataset / uuid / file_name
CFOLD:             label_file = file_path.parent / "label.tex"
CFOLD:             csv_file = file_path.parent / "label.csv"
CFOLD:             bib_file = file_path.parent / "label_table.bib"
CFOLD: 
CFOLD:             try:
CFOLD:                 if not label_file.exists():
CFOLD:                     textpdf_to_latex(file_path, label_file)
CFOLD: 
CFOLD:                 # Open the labeller in VS Code without waiting
CFOLD:                 subprocess.run(["code", str(label_file)], check=True)
CFOLD: 
CFOLD:                 # Monitor for CSV file changes in a separate process if needed
CFOLD:                 # For simplicity, skip automatic BibTeX generation here
CFOLD:                 logger.info(f"Opened label file in VS Code: {label_file}")
CFOLD:             except FileNotFoundError:
CFOLD:                 logger.error("VS Code not found. Please ensure 'code' is in your PATH.")
CFOLD:                 QMessageBox.critical(
CFOLD:                     self,
CFOLD:                     "VS Code Not Found",
CFOLD:                     "Visual Studio Code is not installed or not in your PATH. Please install VS Code or ensure the 'code' command is available."
CFOLD:                 )
CFOLD:                 continue
CFOLD:             except subprocess.SubprocessError as e:
CFOLD:                 logger.error(f"Error opening VS Code: {str(e)}")
CFOLD:                 QMessageBox.critical(
CFOLD:                     self, "Error Opening VS Code", f"Failed to open VS Code for row {row + 1}: {str(e)}"
CFOLD:                 )
CFOLD:                 continue
CFOLD:             except Exception as e:
CFOLD:                 logger.error(f"Error during label workflow: {str(e)}")
CFOLD:                 QMessageBox.critical(
CFOLD:                     self, "Label Workflow Error", f"An unexpected error occurred for row {row + 1}: {str(e)}"
CFOLD:                 )
CFOLD:                 continue
CFOLD: 
CFOLD:     def generate_bibtex(self):
CFOLD:         selected_rows = sorted(set(index.row() for index in self.table.selectedIndexes()))
CFOLD:         if not selected_rows:
CFOLD:             QMessageBox.warning(self, "No Selection", "Please select at least one evidence entry.")
CFOLD:             return
CFOLD: 
CFOLD:         dataset = self.dataset_combo.currentText()
CFOLD:         success_count = 0
CFOLD:         for row in selected_rows:
CFOLD:             uuid_item = self.table.item(row, 4)
CFOLD:             if not uuid_item or not uuid_item.text() or uuid_item.text() == "Unknown":
CFOLD:                 QMessageBox.critical(self, "Invalid Entry", f"Entry in row {row + 1} has no valid UUID.")
CFOLD:                 continue
CFOLD: 
CFOLD:             uuid = uuid_item.text()
CFOLD:             file_name = self.table.item(row, 3).text()
CFOLD:             file_path = self.directory / dataset / uuid / file_name
CFOLD:             csv_file = file_path.parent / "label.csv"
CFOLD:             bib_file = file_path.parent / "label_table.bib"
CFOLD: 
CFOLD:             try:
CFOLD:                 if csv_file.exists():
CFOLD:                     csv_to_bib(csv_file, bib_file, exclude_note=True)
CFOLD:                     logger.info(f"Generated BibTeX file: {bib_file}")
CFOLD:                     success_count += 1
CFOLD:                 else:
CFOLD:                     logger.warning(f"CSV file {csv_file} not found")
CFOLD:                     QMessageBox.warning(
CFOLD:                         self,
CFOLD:                         "CSV Missing",
CFOLD:                         f"No label.csv found for entry in row {row + 1}. BibTeX generation skipped."
CFOLD:                     )
CFOLD:             except Exception as e:
CFOLD:                 logger.error(f"Error generating BibTeX for row {row + 1}: {str(e)}")
CFOLD:                 QMessageBox.critical(
CFOLD:                     self,
CFOLD:                     "BibTeX Generation Error",
CFOLD:                     f"Failed to generate BibTeX for row {row + 1}: {str(e)}"
CFOLD:                 )
CFOLD:                 continue
CFOLD: 
CFOLD:         if success_count > 0:
CFOLD:             QMessageBox.information(
CFOLD:                 self,
CFOLD:                 "BibTeX Generation Complete",
CFOLD:                 f"Successfully generated BibTeX files for {success_count} entries."
CFOLD:             )
CFOLD: 
CFOLD:     def create_label(self):  # Keep original method for backward compatibility
CFOLD:         row = self.table.currentRow()
CFOLD:         if row < 0:
CFOLD:             QMessageBox.warning(self, "No Selection", "Please select an evidence entry.")
CFOLD:             return
CFOLD:         self.create_labels()  # Delegate to multi-selection method
CFOLD: 
CFOLD:     def run_rebut(self):
CFOLD:         row = self.table.currentRow()
CFOLD:         if row < 0:
CFOLD:             QMessageBox.warning(
CFOLD:                 self, "No Selection", "Please select an evidence entry to rebut."
CFOLD:             )
CFOLD:             return
CFOLD: 
CFOLD:         dataset = self.dataset_combo.currentText()
CFOLD:         uuid_item = self.table.item(row, 4)
CFOLD:         if not uuid_item or not uuid_item.text() or uuid_item.text() == "Unknown":
CFOLD:             QMessageBox.critical(self, "Invalid Entry", "Selected entry has no valid UUID.")
CFOLD:             return
CFOLD: 
CFOLD:         uuid = uuid_item.text()
CFOLD:         workdir = self.directory / dataset / uuid
CFOLD: 
CFOLD:         if not workdir.exists():
CFOLD:             logger.warning(f"Working directory {workdir} does not exist for rebuttal")
CFOLD:             QMessageBox.critical(
CFOLD:                 self,
CFOLD:                 "Directory Missing",
CFOLD:                 f"The evidence directory {workdir} does not exist. It may have been moved or deleted."
CFOLD:             )
CFOLD:             return
CFOLD: 
CFOLD:         try:
CFOLD:             rebut_doc(workdir)
CFOLD:         except FileNotFoundError as e:
CFOLD:             logger.warning(f"Rebuttal failed: {str(e)}")
CFOLD:             QMessageBox.critical(
CFOLD:                 self,
CFOLD:                 "Rebuttal Failed",
CFOLD:                 f"Could not run rebuttal: {str(e)}. Ensure required files are available."
CFOLD:             )
CFOLD:         except Exception as e:
CFOLD:             logger.warning(f"Unexpected error during rebuttal: {str(e)}")
CFOLD:             QMessageBox.critical(
CFOLD:                 self, "Rebuttal Error", f"An unexpected error occurred: {str(e)}"
CFOLD:             )

CFOLD: # --- File: docs/usage.md ---
CFOLD: MD: # Usage Guide
CFOLD: MD: 
CFOLD: MD: This guide explains how to use evid to manage PDF documents through its PyQt6-based GUI or command-line interface (CLI).
CFOLD: MD: 
CFOLD: MD: ## Configuration
CFOLD: MD: 
CFOLD: MD: You can configure the default database location by creating a `~/.evidrc` file in YAML format. Example:
CFOLD: MD: 
CFOLD: MD: ```yaml
CFOLD: MD: default_dir: ~/my_custom_evid_db
CFOLD: MD: ```
CFOLD: MD: 
CFOLD: MD: If no `.evidrc` file is found, the default database location is `~/Documents/evid`.
CFOLD: MD: 
CFOLD: MD: ## Launching the Application
CFOLD: MD: 
CFOLD: MD: Launch the GUI with:
CFOLD: MD: 
CFOLD: MD: ```bash
CFOLD: MD: poetry run evid gui
CFOLD: MD: ```
CFOLD: MD: 
CFOLD: MD: This opens the GUI with two tabs: Add and Browse.
CFOLD: MD: 
CFOLD: MD: Alternatively, use the CLI to view available commands:
CFOLD: MD: 
CFOLD: MD: ```bash
CFOLD: MD: poetry run evid --help
CFOLD: MD: ```
CFOLD: MD: 
CFOLD: MD: ## Listing Datasets
CFOLD: MD: 
CFOLD: MD: To see all available datasets, use the CLI:
CFOLD: MD: 
CFOLD: MD: ```bash
CFOLD: MD: poetry run evid list
CFOLD: MD: ```
CFOLD: MD: 
CFOLD: MD: This displays a numbered list of existing datasets in the default database location.
CFOLD: MD: 
CFOLD: MD: ## Creating Datasets
CFOLD: MD: 
CFOLD: MD: ### Via GUI
CFOLD: MD: 
CFOLD: MD: In the Add tab, enter a new dataset name in the "New Dataset" field and click Create.
CFOLD: MD: 
CFOLD: MD: ### Via CLI
CFOLD: MD: 
CFOLD: MD: Create a new dataset with:
CFOLD: MD: 
CFOLD: MD: ```bash
CFOLD: MD: poetry run evid create <dataset_name>
CFOLD: MD: ```
CFOLD: MD: 
CFOLD: MD: This creates a new dataset directory in the default database location.
CFOLD: MD: 
CFOLD: MD: ## Adding Documents
CFOLD: MD: 
CFOLD: MD: ### Via GUI
CFOLD: MD: 
CFOLD: MD: Use the Add tab to log PDFs with metadata.
CFOLD: MD: 
CFOLD: MD: 1. Select or Create a Dataset:
CFOLD: MD:    - Choose an existing dataset from the dropdown or enter a new dataset name and click Create.
CFOLD: MD:    - Datasets are folders in the default database directory where documents are stored.
CFOLD: MD: 
CFOLD: MD: 2. Add a PDF:
CFOLD: MD:    - Click Browse to select a local PDF or enter a URL and click Quick Add URL.
CFOLD: MD:    - The GUI auto-fills metadata (title, authors, dates) from the PDF if possible.
CFOLD: MD: 
CFOLD: MD: 3. Fill Metadata:
CFOLD: MD:    - Edit fields like Title, Authors, Tags, Dates, Label, and URL.
CFOLD: MD:    - Preview the metadata in the preview pane.
CFOLD: MD:    - Note: Metadata fields like title and authors are stored as plain text in `info.yml` for readability, with Danish characters (æ, ø, å) preserved.
CFOLD: MD: 
CFOLD: MD: 4. Save Document:
CFOLD: MD:    - Click Add to save the PDF and metadata to a unique folder in the selected dataset.
CFOLD: MD:    - Metadata is stored in an info.yml file alongside the PDF.
CFOLD: MD: 
CFOLD: MD: ### Via CLI
CFOLD: MD: 
CFOLD: MD: Add PDFs using the CLI with the following command:
CFOLD: MD: 
CFOLD: MD: - Add a PDF (from URL or local file):
CFOLD: MD: 
CFOLD: MD: ```bash
CFOLD: MD: poetry run evid add <url_or_path> [--dataset <dataset>]
CFOLD: MD: ```
CFOLD: MD: 
CFOLD: MD: If `--dataset` is not provided, the CLI prompts you to select an existing dataset or create a new one. The `add` command automatically detects whether the input is a URL (starting with `http://` or `https://`) or a local file path. After adding, it prints the metadata to stdout and prompts to open the `info.yml` file in Visual Studio Code.
CFOLD: MD: 
CFOLD: MD: ## Browsing Documents
CFOLD: MD: 
CFOLD: MD: Use the Browse tab in the GUI to view and manage existing documents.
CFOLD: MD: 
CFOLD: MD: 1. Load a Dataset:
CFOLD: MD:    - Select a dataset from the dropdown and click Load.
CFOLD: MD:    - The table displays metadata (Author, Title, Date, File Name, UUID) for each document entry.
CFOLD: MD: 
CFOLD: MD: 2. View Details:
CFOLD: MD:    - Select a row and click Open Dir to open the document folder in Visual Studio Code.
CFOLD: MD: 
CFOLD: MD: 3. Create Labels:
CFOLD: MD:    - Select one or more entries (hold Ctrl or Shift to select multiple) and click Label Selected to generate LaTeX documents (label.tex) for each selected PDF.
CFOLD: MD:    - Each LaTeX file opens in a separate Visual Studio Code instance, allowing parallel editing without freezing the main application.
CFOLD: MD:    - Edit each LaTeX file in Visual Studio Code (Ctrl+L inserts a \lb snippet) to add labels.
CFOLD: MD:    - Save the file to generate a label.csv, which is then converted to label_table.bib.
CFOLD: MD: 
CFOLD: MD: 4. Generate BibTeX:
CFOLD: MD:    - Select one or more entries and click Generate BibTeX to convert existing label.csv files to label_table.bib for each selected PDF.
CFOLD: MD:    - This is useful for updating BibTeX files after manual edits to label.csv or LaTeX files.
CFOLD: MD: 
CFOLD: MD: 5. Generate Responses:
CFOLD: MD:    - Select an entry and click Rebut to create a response document (rebut.tex) using the BibTeX file.
CFOLD: MD:    - The response lists citations with notes, formatted in LaTeX, suitable for LLM integration.
CFOLD: MD: 
CFOLD: MD: ## Labelling
CFOLD: MD: - When selecting one or more documents and pressing the "Label Selected" button, a LaTeX document is generated for each PDF containing the extracted text.
CFOLD: MD: The LaTeX documents are saved in the same folder as their respective PDFs and opened in Visual Studio Code for editing.
CFOLD: MD: 
CFOLD: MD: - The user can label using their text editor inside the LaTeX document. For VS Code, the following keybinding allows labelling by selecting text and pressing `ctrl+l`:
CFOLD: MD: ```json
CFOLD: MD: [
CFOLD: MD:     {
CFOLD: MD:         "key": "ctrl+l",
CFOLD: MD:         "command": "editor.action.insertSnippet",
CFOLD: MD:         "when": "editorTextFocus && editorLangId == 'latex'",
CFOLD: MD:         "args": {
CFOLD: MD:             "snippet": "\\lb{$1}{${TM_SELECTED_TEXT}}{$2}"
CFOLD: MD:         }
CFOLD: MD:     }
CFOLD: MD: ]
CFOLD: MD: ```
CFOLD: MD: The first field is the label attached (generally a short descriptive string), the second field is the text that was highlighted, and the third field is a comment about the label (for possible use by an LLM).
CFOLD: MD: 
CFOLD: MD: - The header in each LaTeX document causes LaTeX compilation to write the labels to `label.csv`.
CFOLD: MD: - The csv file can be converted to `label_table.bib` by clicking "Generate BibTeX" in the Browse tab or upon exiting the label editor (i.e., closing VS Code after editing label.tex).
CFOLD: MD: - The `label_table.bib` files for each PDF can be concatenated and used to formulate a rebuttal.
CFOLD: MD:   - Note that the first 4 characters of the PDF's UUID are used as a prefix for the BibTeX label, ensuring labels only need to be unique within the same PDF, not across all PDFs in the dataset.
CFOLD: MD: 
CFOLD: MD: ## Tips
CFOLD: MD: 
CFOLD: MD: - Date Extraction: evid automatically extracts dates from PDFs in various formats (e.g., "12/01/2023", "15. januar 2024").
CFOLD: MD: - LaTeX Setup: Ensure a LaTeX distribution is installed for label and response generation.
CFOLD: MD: - VS Code Integration: Use the provided .vscode/keybindings.json for a Ctrl+L shortcut in LaTeX files.
CFOLD: MD: 
CFOLD: MD: For development details, see the Development section.